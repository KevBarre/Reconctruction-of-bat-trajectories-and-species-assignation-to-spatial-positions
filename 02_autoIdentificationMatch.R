# This script allows to assign automated identifications of bat passes to each spatial
# position included in these sound files. This script also check for consistency in
# trajectory assignations thanks to species identification.
#############################################################################################
# Written by Kévin Barré
#############################################################################################

rm(list=ls())

library(data.table) # V1.11.4

setwd("./") # working directory
data <- fread("./TriTrajAGarderFull.csv") # file generated by the script 01 (it is only a sample)
idauto <- fread("./AutoID.csv") # file containing bat passes (5 seconds in our case) automtically identified

tempsFile = data$temps_corrected - data$temps_corrected%%5 # give numbers 5 by 5 seconds 
wavFile = paste("File_",data$soundfile_short,"_",tempsFile,".wav", sep = "") # wav sound file name reconstruction
data = cbind(data, tempsFile, wavFile) # adding columns to the position dataset

# assignation of automatically identified species (from Tadarida software) to each position
Species = vector()
Score = vector()
FreqIdauto = vector()
Order = vector()

pb <- txtProgressBar(min = 0, max = nrow(data), style = 3)
for (i in 1:nrow(data)) {
  setTxtProgressBar(pb, i)
  if(length(which(idauto$Filename == as.character(data[i,29]))) != 0){ # run if we find the corresponding wav file name in automated identification file
    idautoSubset = subset(idauto, idauto$Filename == as.character(data[i,29])) # selection of corresponding identifications in the automated identification file
    idautoSubset$minDiff = abs(list(idautoSubset[,7]) - (data[i,13]/1000)) # computing Khz differences between frequence from position and from automatically identified bat passes
    if(length(which(idautoSubset$minDiff == min(idautoSubset$minDiff))) == 1 ) {
      selection = which(idautoSubset$minDiff == min(idautoSubset$minDiff))  # selection of the closest species in term of frequency
      Species = c(Species, as.character(idautoSubset[selection,3])) # vector completion with the selected species and corresponding score, frequency and order (if several species in a same file)
      Score = c(Score, as.numeric(idautoSubset[selection,5]))
      FreqIdauto = c(FreqIdauto, as.numeric(idautoSubset[selection,7]))
      Order = c(Order, as.character(idautoSubset[selection,2]))
    }
    if(length(which(idautoSubset$minDiff == min(idautoSubset$minDiff))) != 1 
       && length(idautoSubset$Id[which(idautoSubset$minDiff==min(idautoSubset$minDiff) & idautoSubset$Id %in% 
                                       c("Pippip", "Myonat", "MyoGT", "Myoalc", "Myomys", "Myoema", "Myodau", "Myobra", 
                                        "Myocap","Pipkuh", "Pipnat", "Minsch", "Pippyg", "Hypsav", "Eptser","Nycnoc", 
                                        "Nyclei", "Rhieur", "Rhifer", "Rhihip", "Eptnil", "Nyclas", "Tadten", "Barbar", 
                                        "Pleaur", "Pleaus", "Plemac"))])==1) {
      selection = which(idautoSubset$minDiff == min(idautoSubset$minDiff)  # selection of the closest species in term of frequency
                        & idautoSubset$Id %in% c("Pippip", "Myonat", "MyoGT", "Myoalc", "Myomys", "Myoema", "Myodau", "Myobra", 
                                                 "Myocap","Pipkuh", "Pipnat", "Minsch", "Pippyg", "Hypsav", "Eptser","Nycnoc", 
                                                 "Nyclei", "Rhieur", "Rhifer", "Rhihip", "Eptnil", "Nyclas", "Tadten", "Barbar", 
                                                 "Pleaur", "Pleaus", "Plemac"))
      Species = c(Species, as.character(idautoSubset[selection,3])) # vector completion with the selected species and corresponding score, frequency and order (if several species in a same file)
      Score = c(Score, as.numeric(idautoSubset[selection,5]))
      FreqIdauto = c(FreqIdauto, as.numeric(idautoSubset[selection,7]))
      Order = c(Order, as.character(idautoSubset[selection,2]))
    }
    if(length(which(idautoSubset$minDiff == min(idautoSubset$minDiff))) != 1 
       && length(idautoSubset$Id[which(idautoSubset$minDiff==min(idautoSubset$minDiff) & idautoSubset$Id %in% 
                                       c("Pippip", "Myonat", "MyoGT", "Myoalc", "Myomys", "Myoema", "Myodau", "Myobra", 
                                         "Myocap","Pipkuh", "Pipnat", "Minsch", "Pippyg", "Hypsav", "Eptser","Nycnoc", 
                                         "Nyclei", "Rhieur", "Rhifer", "Rhihip", "Eptnil", "Nyclas", "Tadten", "Barbar", 
                                         "Pleaur", "Pleaus", "Plemac"))])!=1) {
      Species = c(Species, "NA")
      Score = c(Score, "NA")
      FreqIdauto = c(FreqIdauto, "NA")
      Order = c(Order, "NA")
    } 
  } else { # if no match 
    Species = c(Species, "NA")
    Score = c(Score, "NA")
    FreqIdauto = c(FreqIdauto, "NA")
    Order = c(Order, "NA")
  }
}
dataFinal = cbind(data, Species, Score, FreqIdauto, Order)

# replace assignations to myotis species level with myotis group
for (i in 1:nrow(dataFinal)) {
  if(dataFinal$Species[i] %in% c("Myonat", "MyoGT", "Myoalc", "Myomys", "Myoema", "Myodau", "Myobra", "Myocap")) dataFinal$Species[i] = "Myosp"
  if(dataFinal$Species[i] %in% c("Pleaur", "Pleaus", "Plemac")) dataFinal$Species[i] = "Plesp"
}

# replace absent species from study area
for (i in 1:nrow(dataFinal)) {
  if(dataFinal$Species[i] %in% c("Pipkuh", "Hypsav")) dataFinal$Species[i] = "Pipnat"
  if(dataFinal$Species[i] %in% c("Pippyg", "Minsch")) dataFinal$Species[i] = "Pippip"
}

# checking consistency of positions assigned to trajectory in rounds > 1 in script 01
# in order to ensure that 2 indiviuals can not be confounded in 1 trajectory
IdTrajNew = vector(length = 1000)
dataFinal = cbind(dataFinal, IdTrajNew)
for(i in unique(dataFinal$IdTraj)) {
  print(i)
  if(dataFinal$round[which(dataFinal$IdTraj == i)] %in% c("2","3","4","5","6","7","8","9","10","11")) {
    sub = subset(dataFinal, dataFinal$round == 1 & dataFinal$IdTraj == i)
    meanFreq = mean(sub$fsigmax..Hz.)
    for (j in 1:nrow(dataFinal[which(dataFinal$round != c("1", "NA") & dataFinal$IdTraj == i)])) {
      if(abs(meanFreq - mean(dataFinal$fsigmax..Hz.[which(dataFinal$round != c("1", "NA") & dataFinal$IdTraj == i)][j])) > 3000){
        dataFinal$IdTrajNew[which(dataFinal$round != c("1", "NA") & dataFinal$IdTraj == i)][j] = paste(i, "new", sep = "")
      } else {dataFinal$IdTrajNew[which(dataFinal$round != c("1", "NA") & dataFinal$IdTraj == i)][j] = paste(i, sep = "")}
    }
    for(k in 1:nrow(dataFinal[which(dataFinal$round == c("1", "NA") & dataFinal$IdTraj == i)])){
      dataFinal$IdTrajNew[which(dataFinal$round == c("1", "NA") & dataFinal$IdTraj == i)][k] = paste(i, sep = "")
    }
  } else {dataFinal$IdTrajNew[which(dataFinal$IdTraj == i)] = paste(i, sep = "")}
}

# if new trajectories contain more than one species group (Pipistrellus, Myotis, Plecotus, Eptesicus, Nyctalus)
IdTrajNewSpecies = vector(length = 1000)
dataFinal = cbind(dataFinal, IdTrajNewSpecies)
for (i in 1:nrow(dataFinal)) {
  if(dataFinal$IdTrajNew[i] %in% paste(dataFinal$IdTraj[i],"new", sep="")) {
    if(dataFinal$Species[i] %in% c("Pippip", "Pipnat")) {
      dataFinal$IdTrajNewSpecies[i] = paste(dataFinal$IdTrajNew[i], "Pip", sep = "")
    }
    if(dataFinal$Species[i] %in% c("Plesp")) {
      dataFinal$IdTrajNewSpecies[i] = paste(dataFinal$IdTrajNew[i], "Plesp", sep = "")
    }
    if(dataFinal$Species[i] %in% c("Myosp")) {
      dataFinal$IdTrajNewSpecies[i] = paste(dataFinal$IdTrajNew[i], "Myosp", sep = "")
    }
    if(dataFinal$Species[i] %in% c("Nycnoc", "Nyclei", "Eptser")) {
      dataFinal$IdTrajNewSpecies[i] = paste(dataFinal$IdTrajNew[i], "Eptnyc", sep = "")
    }
    if(dataFinal$Species[i] %in% c("noise")) {
      dataFinal$IdTrajNewSpecies[i] = paste(dataFinal$IdTrajNew[i], sep = "")
    }
  } else {dataFinal$IdTrajNewSpecies[i] = dataFinal$IdTrajNew[i]}
}

# for trajectories with more than 1 species automatically identified, selection of the most likely one
state = vector(length = 1000)
SpeciesInitial = dataFinal$Species
dataFinal = cbind(dataFinal, state, SpeciesInitial)
for (j in unique(dataFinal$IdTrajNewSpecies)) {
  print(j)
  if(length(dataFinal$IdTrajNewSpecies[which(dataFinal$IdTrajNewSpecies == j)])>1){
  species = c()
  number = c()
  for (e in unique(dataFinal$Species[which(dataFinal$IdTrajNewSpecies == j)])) {
    species = c(species, e)
    dataFinalSubset = dataFinal[which((dataFinal$IdTrajNewSpecies == j) & (dataFinal$Species == e)),]
    number = c(number, nrow(dataFinalSubset))
  }
    number2 = as.data.frame(cbind(species, number))
    if(length(number2$species[which(number2$species %in% c("noise"))])>0) {datatot = number2[-which(number2$species %in% c("noise")), ]}else{datatot=number2}
    if(nrow(datatot) == 0) {
      dataFinal$Species[which(dataFinal$IdTrajNewSpecies == j)] = "noise"
      dataFinal$state[which(dataFinal$IdTrajNewSpecies == j)] = "ok"
    }
    if((length(datatot$species[which(datatot$species %in% c("Pippip", "Myosp", "Plesp", "Pipkuh", "Pipnat", "Minsch", "Pippyg", "Hypsav", "Eptser",
                            "Nycnoc", "Nyclei", "Rhieur", "Rhifer", "Rhihip", "Eptnil", "Nyclas", "Tadten", "Barbar"))]) > 0)
       & (length(max(as.numeric(datatot$number)))==1)){
      dataFinal$Species[which(dataFinal$IdTrajNewSpecies == j)] = as.character(datatot[which(datatot$number==max(as.numeric(as.character(datatot$number)))), 1])
      dataFinal$state[which(dataFinal$IdTrajNewSpecies == j)] = "ok"
    }
  }
}

# sorting out automatic pulses (which help to check the antenna worked well on the field)
data2 = data[-which(data$fmin..Hz.>36240 & data$fmin..Hz.<36700 & data$fsigmax..Hz.>39950 & data$fsigmax..Hz.<40250 & data$fmax..Hz.>43740 & 
                     data$fmax..Hz.<44380 & data$angle< as.numeric(-37) & data$durée..s.>0.0055 & data$durée..s.<0.0075),]

# correction of position type (individual or trajectory) after previous clean up steps
for (j in unique(data2$IdTrajNewSpecies)) {
  print(j)
  if(length(data2$IdTrajNewSpecies[which(data2$IdTrajNewSpecies == j)])==1){
    data2$IdTrajNewSpecies[which(data2$Type == j)] = "individualPosition"
  }else{data2$IdTrajNewSpecies[which(data2$Type == j)] = "trajectory"}
}
# correction of flight speed after previous clean up steps
Vitesse = function(p1,p2)
{
  if (p2$temps..s. == p1$temps..s.) # if time of recording is identical
  {
    999
  }
  else
  { # distance between the points / time difference of recording
    ((p2$x..m. - p1$x..m.)^2 + (p2$y..m. - p1$y..m.)^2 + (p2$z..m. - p1$z..m.)^2)^0.5 / (p2$temps..s. - p1$temps..s.)
  }
}

data2=data2[order(data2$IdTrajNewSpecies,data2$round,data2$temps..s.),]
Vfinal2=rep(999,nrow(data2))
pb <- txtProgressBar(min = 0, max = nrow(data2), style = 3)
for (i in 2:nrow(data2)){
  setTxtProgressBar(pb, i)
  if((data2$IdTrajNewSpecies[(i-1)]==data2$IdTrajNewSpecies[i])&(data2$round[(i-1)]==data2$round[i]))
  {
    Vfinal2[i]=Vitesse(data2[(i-1),],data2[i,])
    
  }
}

data2$Vfinal = Vfinal2
write.csv(data2, "./", row.names=F)

